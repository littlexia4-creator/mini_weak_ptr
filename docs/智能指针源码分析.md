 计数器基类 纯虚类
     _Ref_count_base{
            virtual void _Destroy() _NOEXCEPT = 0;
            virtual void _Delete_this() _NOEXCEPT = 0;

            _Atomic_counter_t _Uses;  //  强指针计数，用于管理资源
            _Atomic_counter_t _Weaks; // 弱指针计数+是否存在强指针（是为1否为0），用于管理自身this
     }

     强弱指针计数器派生类：
     _Ref_count： public _Ref_count_base
 //真正的计数器对象，使用时需要将其强转为父类指针，仅仅使用接口
     {
        _Ty * _Ptr; //管理的内部指针
     }


智能指针基类
封装强弱均需要用到的内部接口，与便于强弱指针转化
class _Ptr_base{
element_type* _Ptr{nullptr};	//内部指针，只负责对外get(),不删除
_Ref_count_base* _Rep{nullptr};//基类计数器对象//便于发生多态//用于管理智能指针的次数
}


强指针类
shared_ptr: public  _Ptr_base
封装智能指针对外使用的接口

弱指针类
weak_ptr:public  _Ptr_base
 封装弱指针的少量的接口



     //强指针直接构造（拿原始指针构造）时：
     //1. 初始化_Ty * _Ptr
     //2. 创建_Ref_count唯一计数器子类对象
     //3. _Ref_count_base对象构造时，强弱指针计数分别为_Uses = 1 并且 _Weaks = 1


//弱指针生出一个强指针时，计数器_Uses +1
//强指针引用个数为0时，删除内部指针，_Weaks-=1，
//弱指针引用计数为0时，删除计数器


其实有两种资源管理器：
_Ref_count_resource/_Ref_count
前者需要deleter() 后者直接delete
